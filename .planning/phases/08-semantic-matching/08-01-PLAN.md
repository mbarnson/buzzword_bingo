# Phase 8 Plan 01: Replace FuzzyMatcher with NLContextualEmbedding

## Objective
Replace Levenshtein-based fuzzy matching with Apple's NLContextualEmbedding for semantic similarity matching. No fallbacks, no backward compatibility - clean swap.

## Context
@Buzzword Bingo/Buzzword Bingo/Services/FuzzyMatcher.swift - current implementation (keep but don't use)
@Buzzword Bingo/Buzzword Bingo/Models/BingoCard.swift - calls FuzzyMatcher at line 83

## Tasks

### Task 1: Create SemanticMatcher Service
**Type:** create
**Files:** `Buzzword Bingo/Buzzword Bingo/Services/SemanticMatcher.swift`
**Action:**
- Import NaturalLanguage framework
- Create `SemanticMatcher` class (not struct - needs to hold embedding model)
- Load `NLContextualEmbedding.contextualEmbedding(for: .english)` on init
- Handle asset availability check with `hasAvailableAssets` / `requestAssets()`
- Implement mean pooling for token vectors → sentence vector (use Accelerate/vDSP)
- Implement cosine similarity calculation
- Method: `findBestMatch(forPhrase:in:threshold:) -> (index: Int, word: String, score: Double)?`
  - Same signature as FuzzyMatcher for easy swap
  - Default threshold: 0.65 (lower than Levenshtein's 0.7 - semantic is more forgiving)
- Pre-compute and cache buzzword embeddings for performance

**Verify:** SemanticMatcher compiles with NaturalLanguage import

### Task 2: Wire SemanticMatcher into BingoCard
**Type:** modify
**Files:** `Buzzword Bingo/Buzzword Bingo/Models/BingoCard.swift`
**Action:**
- Change import/usage from FuzzyMatcher to SemanticMatcher
- Update `markMatchingSquare(forPhrase:)` to use SemanticMatcher
- Pass threshold of 0.65 explicitly
- NO fallback to FuzzyMatcher - if SemanticMatcher fails, that's the result

**Verify:** BingoCard uses only SemanticMatcher

### Task 3: Build & Test
**Type:** verify
**Action:** Build for macOS, verify no compile errors
**Verify:** `xcodebuild -scheme "Buzzword Bingo" -destination "platform=macOS" -quiet`

---

**checkpoint:human-verify**
Test semantic matching:
1. Start a game, enable mic
2. Say variations that would fail Levenshtein:
   - "I'd like to double click on that" (should match "double-click")
   - "circle the wagon" (should match "circle the wagons" or similar)
   - Paraphrased buzzwords
3. Check if matches feel more natural than before

Type "approved" if semantic matching works better, or describe issues.

---

## Verification
- [ ] SemanticMatcher created with NLContextualEmbedding
- [ ] Cosine similarity implemented correctly
- [ ] BingoCard uses SemanticMatcher (not FuzzyMatcher)
- [ ] FuzzyMatcher.swift still exists but is unused
- [ ] Both platforms build

## Success Criteria
- Semantic variations match correctly ("wagon" ≈ "wagons")
- Phrases with extra words still match ("let's double-click" ≈ "double-click")
- No fallback to FuzzyMatcher - clean separation
- Performance acceptable for real-time speech matching

## Output
Create `08-01-SUMMARY.md` documenting semantic matching implementation.
