# Phase 8 Plan 02: Keyword-Indexed Hybrid Matching

## Objective
Replace brute-force chunked semantic matching with a keyword-indexed hybrid approach that:
1. Builds a keyword index mapping significant words to buzzwords containing them
2. Uses instant hash lookup to find candidate buzzwords
3. Matches single-word buzzwords immediately (no semantic needed)
4. Uses targeted semantic matching only for multi-word buzzwords, comparing similar-length strings
5. Falls back to semantic matching for paraphrase detection when no keyword hits

## Context
@Buzzword Bingo/Buzzword Bingo/Services/SemanticMatcher.swift - current chunking implementation
@Buzzword Bingo/Buzzword Bingo/Models/BingoCard.swift - calls SemanticMatcher at line 83

**Problem:** Current approach does O(chunks × buzzwords × d) semantic comparisons per callback. With 50-word windows, 5-word chunks, and 24 buzzwords, that's ~24 × 24 × 512 = 295k operations. Even worse, comparing 5-word chunks to 1-word buzzwords causes signal dilution.

**Solution:** Keyword-indexed lookup is O(w) scan + O(hits × candidates × d), typically ~50 + 512 = 562 operations. Plus, semantic comparison happens on similar-length strings.

## Tasks

### Task 0: Define Normalization Pipeline
**Type:** design
**Action:** Establish consistent normalization rules used everywhere:
1. Lowercase the input
2. Split on non-alphanumeric characters (this handles contractions: "let's" → ["let", "s"])
3. Filter out empty strings
4. Result: array of lowercase alphanumeric word tokens

**Key invariants:**
- All keyword index keys are lowercase
- All phrase words are normalized before lookup
- Comparison is always normalized vs normalized

**Verify:** Document in code comments

### Task 1: Add Stopwords List to SemanticMatcher
**Type:** modify
**Files:** `Buzzword Bingo/Buzzword Bingo/Services/SemanticMatcher.swift`
**Action:**
- Add static Set of English stopwords:
  ```
  "the", "a", "an", "is", "are", "was", "were", "be", "been", "being",
  "it", "its", "this", "that", "these", "those", "i", "you", "we", "they",
  "to", "of", "in", "on", "at", "by", "for", "with", "from", "and", "or",
  "but", "so", "if", "then", "let", "s", "d", "t", "ll", "ve", "re"
  ```
- Add helper method `extractKeywords(_ buzzword: String) -> [String]`
  - Normalize, split into words, filter out stopwords
  - Return array of significant keywords

**Verify:** `extractKeywords("Let's double-click on that")` returns `["double", "click"]`

### Task 2: Create KeywordIndex with Caching
**Type:** modify
**Files:** `Buzzword Bingo/Buzzword Bingo/Services/SemanticMatcher.swift`
**Action:**
- Add nested struct `BuzzwordEntry`:
  ```swift
  struct BuzzwordEntry {
      let index: Int           // Square index on the card
      let word: String         // Original buzzword
      let wordCount: Int       // Word count for window sizing
      let normalized: String   // Normalized form
      let keywords: [String]   // Extracted keywords for this buzzword
  }
  ```
- Add property `keywordIndex: [String: [BuzzwordEntry]]`
- Add property `currentBuzzwordSet: Set<Int>` to track which buzzword indices are indexed
- Add method `buildIndex(for buzzwords: [(index: Int, word: String)])`
  - Check if buzzword indices match `currentBuzzwordSet` - if so, skip rebuild
  - For each buzzword, extract keywords
  - **Edge case:** If buzzword has no keywords after stopword filtering (e.g., "It"), use the full normalized word as keyword
  - Map each keyword to the buzzword entry
  - Example: "boil" → [BuzzwordEntry for "Boil the ocean"]
  - Update `currentBuzzwordSet`

**Verify:** Index is built once per game, not per callback

### Task 3: Implement Hybrid Matching Logic
**Type:** modify
**Files:** `Buzzword Bingo/Buzzword Bingo/Services/SemanticMatcher.swift`
**Action:**
- Replace `findBestMatch` with hybrid approach:
  1. Normalize phrase into word array with positions
  2. Build/use cached index for provided buzzwords
  3. Scan phrase words against keyword index (O(w) hash lookups)
  4. For each hit:
     - **Single-word buzzword:** Match ONLY if `phraseWord == entry.normalized` (exact match after normalization). This prevents "this" in speech matching a hypothetical buzzword "This" when context differs.
     - **Multi-word buzzword:** Extract window of `entry.wordCount` words:
       - Window ends at current position (keyword is at or near end of window)
       - If not enough preceding words, take what's available
       - Do semantic comparison between window and buzzword (similar lengths = better signal)
       - Use threshold 0.85 for targeted comparison (similar-length strings can be stricter)
  5. **Semantic fallback (REQUIRED for paraphrases):** If no keyword matches found, fall through to semantic matching for paraphrase detection:
     - Use last 5 words of phrase (short chunk)
     - Compare against all unmarked buzzwords
     - Use threshold 0.88
     - This catches: "working together" → "Synergy", "joined forces" → "Synergy"
- Track best match across all hits
- Return highest-scoring match above threshold
- Log: `[SemanticMatcher] keyword hit: "leverage" → instant match "Leverage"` or `[SemanticMatcher] keyword hit: "ocean" → semantic check "boil the ocean" (0.92)`

**Verify:** Single-word matches are instant; multi-word uses targeted semantic; paraphrases still work via fallback

### Task 4: Remove Old Chunking Code
**Type:** modify
**Files:** `Buzzword Bingo/Buzzword Bingo/Services/SemanticMatcher.swift`
**Action:**
- Remove `chunkWordCount`, `chunkStride` properties
- Remove `generateChunks(from:)` method
- Keep embedding/similarity methods for targeted semantic matching
- Update logging to show keyword-based matching

**Verify:** No more O(chunks × buzzwords) iteration

### Task 5: Build & Test Both Platforms
**Type:** verify
**Action:** Build for both macOS and iOS, verify no compile errors
**Verify:**
```bash
xcodebuild -scheme "Buzzword Bingo" -destination "platform=macOS" -quiet build
xcodebuild -scheme "Buzzword Bingo" -destination "generic/platform=iOS" -quiet build
```

---

**checkpoint:human-verify**
Test keyword-indexed hybrid matching:
1. Start a game, enable mic
2. Test single-word matches (should be instant):
   - Say "leverage" → should match "Leverage" immediately
   - Say "synergy" → should match "Synergy" immediately
3. Test multi-word matches:
   - Say "boil the ocean" → keyword "boil" or "ocean" triggers semantic check
   - Say "at the end of the day" → keyword "end" or "day" triggers check
4. Check debug logs - should see keyword hits, not chunk iterations
5. Verify no false negatives from previous testing

Type "approved" if matching is fast and accurate, or describe issues.

---

## Verification
- [ ] Normalization pipeline is consistent (lowercase, split on non-alphanumeric)
- [ ] Stopwords list correctly filters common words
- [ ] Keyword index maps significant words to buzzwords
- [ ] Index caching prevents rebuild on every callback
- [ ] Edge case: buzzwords with only stopwords still get indexed
- [ ] Single-word buzzwords match instantly via exact normalized comparison
- [ ] Multi-word buzzwords use targeted N-word window comparison
- [ ] Semantic fallback handles paraphrases when no keyword match
- [ ] Performance is significantly improved (no more O(chunks × buzzwords))
- [ ] Both platforms build

## Success Criteria
- "leverage" matches "Leverage" instantly (no semantic needed)
- "boil the ocean" matches via keyword lookup + targeted semantic
- "working together" still matches "Synergy" via semantic fallback
- Logs show keyword-based matching, not chunk iteration
- Matching rate improves from ~25% to ~80%+
- No degradation in false positive rate
- No regression on paraphrase matching

## Output
Create `08-02-SUMMARY.md` documenting the keyword-indexed hybrid implementation.
